---
title: 7、数据库连接
date: 2025-04-07
---

# 前言

访问数据库，进行交互是很基础且重要的功能。

本文将通过一个很简单的开源数据库pocketbase演示数据库的链接。

# MVVM

**MVVM**（**Model–view–viewmodel**）是一种软件[架构模式](https://zh.wikipedia.org/wiki/架构模式)。本项目采用经典的MVVM模型进行前后端交互：

数据流向：

```
用户操作 -> View -> ViewModel -> Model(API) -> 后端服务器
后端服务器 -> Model(API) -> ViewModel -> View(UI更新)
```

接下来以登录为例介绍。

## Model层

Model定义了数据实体，即我们发送与接受的具体数据定义。

我们查看pocketbase的API规则，可以看到数据库的登录设计接口为：

**API details**

POST：/api/collections/users/auth-with-password

**Body Parameters**

| Param              | Type   | Description                                                  |
| :----------------- | :----- | :----------------------------------------------------------- |
| (Required)identity | String | The **username** or **email** of the record to authenticate. |
| (Required)password | String | The auth record password.                                    |

**Responses**

```
{
    "token": "JWT_TOKEN",
    "record": {
        "id": "RECORD_ID",
        "collectionId": "_pb_users_auth_",
        "collectionName": "users",
        "username": "username123",
        "verified": false,
        "emailVisibility": true,
        "email": "test@example.com",
        "created": "2022-01-01 01:00:00.123Z",
        "updated": "2022-01-01 23:59:59.456Z",
        "name": "test",
        "avatar": "filename.jpg"
    }
}
```

根据这个接口去定义数据实体：

```kotlin
package com.harry.hanakoisteward.data.entity

data class AuthEntity(
    val identity: String,
    val password: String,
)

data class AuthResponse(
    val token: String = "",
    val record: Record = Record()
)

data class Record(
    val id: String = "",
    val collectionId: String = "",
    val collectionName: String = "",
    val created: String = "",
    val updated: String = "",
    val username: String = "",
    val email: String = "",
    val verified: Boolean = false,
    val emailVisibility: Boolean = false,
    val someCustomField: String = ""
)
```

**接口调用**

```kotlin
package com.harry.hanakoisteward.data.network

import com.harry.hanakoisteward.data.entity.AuthEntity
import com.harry.hanakoisteward.data.entity.AuthResponse
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.http.Body
import retrofit2.http.Headers
import retrofit2.http.POST

private const val BASE_URL = "http://xxx"

class AuthInterceptor(private val tokenProvider: () -> String) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val originalRequest: Request = chain.request()
        val newRequest: Request = originalRequest.newBuilder()
            .header("Authorization", "Bearer ${tokenProvider()}") // 动态获取 token
            .build()
        return chain.proceed(newRequest)
    }
}

// 假设你有一个全局的 token 管理器
object TokenManager {
    var token: String = ""
}

private val client = OkHttpClient.Builder()
    .addInterceptor(AuthInterceptor { TokenManager.token }) // 动态获取 token
    .build()

val retrofit = Retrofit.Builder()
    .client(client) // 使用自定义的 OkHttpClient
    .addConverterFactory(GsonConverterFactory.create()) // 添加 Gson 转换器
    .addConverterFactory(ScalarsConverterFactory.create())
    .baseUrl(BASE_URL)
    .build()

interface AuthService {
    @POST("/api/collections/users/auth-with-password")
    @Headers("Content-Type: application/json")
    suspend fun auth(@Body data: AuthEntity): AuthResponse
}

object AuthApi {
    val retrofitService : AuthService by lazy {
        retrofit.create(AuthService::class.java)
    }
}
```

