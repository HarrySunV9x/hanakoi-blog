---
title: 8.build.gradle
date: 2025-04-22
---

# 前言

本文讲简单讲解Android的构建系统，详细可在谷歌官网阅读：

[Gradle 构建概览](https://developer.android.com/build/gradle-build-overview?hl=zh-cn)

在现代软件开发中，各语言生态普遍通过构建工具实现依赖管理和项目配置：

前端项目会用 npm/yarn 管理 JavaScript 依赖；

Python 生态通过 pip 处理包管理；

C/C++ 项目常用 CMake 生成构建文件并配合 Ninja 执行构建。

而对于 Android 及 Java 生态来说，主流的构建工具包括 Gradle 和 Maven，其中 Gradle 成为 Android 官方推荐的构建系统。

Gradle 的核心机制是通过 build.gradle 文件实现项目配置：根项目的 build.gradle 负责全局配置（如依赖仓库声明、插件版本管理），而每个模块的 build.gradle 则定义模块专属的编译选项、依赖关系及构建任务。这种分层配置架构既保证了项目的一致性，又支持模块化开发需求。开发者可以通过编写声明式的 DSL 脚本，高效管理第三方库依赖、配置多渠道构建，并实现自动化测试与部署等。

# 构建系统

当点击 Android Studio 中的 "Build" 按钮时，实际上是触发了其集成的构建系统。这个系统的核心任务是将项目源代码、资源文件、依赖库等所有元素，通过一系列定义的步骤（如编译、资源处理、代码混淆、打包、签名等），最终构建成一个可以在 Android 设备上安装和运行的 APK (Android Package) 文件。

如果尝试手动完成这个过程，将极其繁琐。开发者需要依次调用各种命令行工具，例如（以下步骤来自AI，仅用于描述整个过程）：

- 编译 Java/Kotlin 源代码 (javac, kotlinc)。
- 处理资源文件（使用 aapt2）。
- 将 Java 字节码转换成 Dalvik/ART 字节码（使用 d8）。
- 将编译后的代码、处理过的资源、库文件等打包成一个未签名的 APK。
- 对 APK 进行签名 (apksigner) 以验证其来源和完整性。

除了**命令复杂**，我们还将面临构建**不同版本**的需求：

- **构建类型 (Build Types)**：区分用于内部测试和调试的 debug 版本（可能包含额外的日志、调试工具）和用于最终用户发布的 release 版本（通常经过优化、混淆和使用正式签名）。
- **产品风味 (Product Flavors)**：针对不同的目标群体或分发渠道创建不同的变体，比如免费版/付费版、针对不同应用商店的版本，或者包含不同定制功能（如不同的 API 端点、资源或品牌元素）的版本。

Gradle 使用[领域专用语言](https://docs.gradle.org/current/dsl) (DSL) 来配置 build，基于**任务**的方法来整理和运行这些命令。以便灵活的实现自动化构建。

# build.gradle

Android Studio项目中常见的配置：

```kotlin
plugins {
    ...
}

android {
    ...
}

dependencies {
    ...
}
```

**plugins**

声明项目所需的 Gradle 插件，例：

```groovy
plugins {
    id 'com.android.application'  // 标记这是一个 Android 应用模块
    id 'kotlin-android'          // 支持 Kotlin 语言
}
```

**android**

配置 Android 项目的构建选项，包括编译版本、构建工具、默认配置等。

```groovy
android {
    compileSdkVersion 33         // 指定编译用的 SDK 版本
    buildToolsVersion "33.0.0"   // 构建工具版本（通常可省略）

    defaultConfig {
        applicationId "com.example.myapp"  // 应用唯一标识（包名）
        minSdkVersion 21         // 最低支持的 Android 版本
        targetSdkVersion 33      // 目标适配的 Android 版本
        versionCode 1            // 内部版本号（整数）
        versionName "1.0"        // 用户可见的版本号
    }

    buildTypes {
        release {
            minifyEnabled true   // 是否启用代码混淆
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            debuggable true      // 允许调试
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_11  // Java 版本兼容性
        targetCompatibility JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = '11'        // Kotlin 的 JVM 目标版本
    }
}
```

